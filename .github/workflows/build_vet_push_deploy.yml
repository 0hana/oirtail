name: Build -> Vet -> Push -> Deploy

on:
  push:
    branches: [ main, github-actions ]

# if multiple pushes occur, they could interrupt each other,
# so we tell github/actions to queue up each workflow and let it
# run to completion (or failure) before starting the next workflow in the queue
# ------------------------------------------------------------------------------
concurrency:
  group: production-deploy   # group id
  cancel-in-progress: false  # allow workflow in progress to complete before starting

jobs:
  increment_version:
    runs-on: ubuntu-latest
    outputs:
      version_tag: ${{ steps.new_version.outputs.version_tag }}
    steps:
      - name: acquire ${{ github.repository }} repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # access to all tags to get latest
      - name: compute new semantic version number from git commit tags
        id:   new_version
        run: |
          # Embedded version increment shell logic
          latest_tag="$(git describe --tags --abbrev=0 2>'/dev/null' || printf '%s\n' '0.0.0')"
          # --abbrev=0 removes abbreviated commit hash from output
          major="$(printf '%s\n' "${latest_tag}" | cut -d. -f1)"
          minor="$(printf '%s\n' "${latest_tag}" | cut -d. -f2)"
          patch="$(printf '%s\n' "${latest_tag}" | cut -d. -f3)"
          # We're only going to increment patch version,
          # so this logic is too oversimplified for a more comprehensive auto-versioning system
          printf '%s\n' "version_tag=${major}.${minor}.$((patch+1))" | tee -a "${GITHUB_OUTPUT}"

  build_vet_push:
    needs: increment_version
    runs-on: ubuntu-latest
    steps:
      - name: acquire ${{ github.repository }} repo
        uses: actions/checkout@v4
      - name: build docker image
        run: |
          docker build -t "oirtail:${version_tag}" ./
        env:
          version_tag: ${{ needs.increment_version.outputs.version_tag }}
      - name: start docker container
        run: |
          docker run -dp 80:80 --name evil-oirtail "oirtail:${version_tag}"
        env:
          version_tag: ${{ needs.increment_version.outputs.version_tag }}
      - name: (nektos/act-Only) do NOT attempt surgery on liatrio apprentice-action
        if: ${{ env.ACT }}
        run: |
          printf '%s\n' '(NEKTOS/ACT-ONLY)'
      - name: (Github-Only) attempt surgery on liatrio apprentice-action
        if: ${{ !env.ACT }}
        run: |
          printf '%s\n' '(GITHUB-ONLY IN-FLIGHT-PATCH)'
          target="$(find ../../_actions/liatrio/ -type f -name 'endpoint.test.js')"
          line_1="$(grep -n ' *it("should return a minified JSON object.", async () => {'    "${target}" | cut -d: -f1 || echo 0)"
          line_2="$(grep -n ' *const res = await axios(`http://${dockerBridgeIP}:80/`);'     "${target}" | cut -d: -f1 \
          | grep "^$((line_1+1))$" || echo 0)"
          line_3="$(grep -n ' *// TODO: Finish this test'                                    "${target}" | cut -d: -f1 || echo 0)"
          line_4="$(grep -n ' *throw new Error("TypeError: Object(...) is not a function");' "${target}" | cut -d: -f1 || echo 0)"
          line_5="$(grep -n ' *});'                                                          "${target}" | cut -d: -f1 \
          | grep "^$((line_4+1))$" || echo 0)"
          if [ -n "${target}" ]             \
          && [ "$((line_5-line_4))" -eq 1 ] \
          && [ "$((line_4-line_3))" -eq 1 ] \
          && [ "$((line_3-line_2))" -eq 1 ] \
          && [ "$((line_2-line_1))" -eq 1 ]
          then
          cat > patch.txt << 'EOF'
                  const res = await axios({
                    url: `http://${dockerBridgeIP}:80/`,
                    method: "get",
                    transformResponse: [(data) => data]
                    });
                  expect(() => JSON.parse(res.data)).to.not.throw();
                  expect(/\s/.test(res.data.replace(/"(\\.|[^"\\])*"/g, "\"\""))).to.be.false;
          EOF
          sed -i'' "${line_2},${line_4}d" "${target}"  # delete the bad code
          sed -i'' "${line_1}r patch.txt" "${target}"  # inject patch
          fi
      - name: evaluate docker image
        uses: liatrio/github-actions/apprentice-action@v1.0.0  # commit 0b41561cca6822cc8d880fe0e49e7807a41fdf91
