name: Build -> Vet -> Push -> Deploy

on:
  push:
    branches: [ main, github-actions ]

# if multiple pushes occur, they could interrupt each other,
# so we tell github/actions to queue up each workflow and let it
# run to completion (or failure) before starting the next workflow in the queue
# ------------------------------------------------------------------------------
concurrency:
  group: production-deploy   # group id
  cancel-in-progress: false  # allow workflow in progress to complete before starting

jobs:
  # Compute next Semantic Version number (vX.Y.Z)
  # ----------------------------------------------------------------------------
  increment_version:
    runs-on: ubuntu-latest
    outputs:
      version_tag: ${{ steps.new_version.outputs.version_tag }}
    steps:
      - name: acquire ${{ github.repository }} repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # access to all tags to get latest
      - name: compute new semantic version number from git commit tags
        id:   new_version
        run: |
          # Embedded version increment shell logic
          latest_tag="$(git describe --tags --abbrev=0 2>'/dev/null' || printf '%s\n' 'v0.0.-1')"
          # --abbrev=0 removes abbreviated commit hash from output
          major="$(printf '%s\n' "${latest_tag#v}" | cut -d. -f1)"
          minor="$(printf '%s\n' "${latest_tag#v}" | cut -d. -f2)"
          patch="$(printf '%s\n' "${latest_tag#v}" | cut -d. -f3)"
          # We're only going to increment patch version,
          # so this logic is too oversimplified for a more comprehensive auto-versioning system
          printf '%s\n' "version_tag=v${major}.${minor}.$((patch+1))" | tee -a "${GITHUB_OUTPUT}"

  build_vet_push:
    needs: increment_version
    runs-on: ubuntu-latest
    steps:
      - name: compute docker image tag name
        env:
          version_tag: ${{ needs.increment_version.outputs.version_tag }}
        run: |
          readonly \
          IMAGE_NAME="$(printf '%s' "ghcr.io/${GITHUB_REPOSITORY}:${version_tag}" | tr '[:upper:]' '[:lower:]')"
          printf '%s\n' "IMAGE_NAME""=${IMAGE_NAME}"           >> "${GITHUB_ENV}"
          printf '%s\n' "IMAGE_LATEST=${IMAGE_NAME%:*}:latest" >> "${GITHUB_ENV}"
      - name: acquire ${{ github.repository }} repo
        uses: actions/checkout@v4
      - name: build docker image
        run: |
          docker build                                                                                \
            --tag   "${IMAGE_NAME}"                                                                   \
            --tag   "${IMAGE_LATEST}"                                                                 \
            --label "org.opencontainers.image.title`    `=${{ github.event.repository.name }}"        \
            --label "org.opencontainers.image.description=${{ github.event.repository.description }}" \
            --label "org.opencontainers.image.url`      `=${{ github.event.repository.html_url }}"    \
            --label "org.opencontainers.image.source`   `=${{ github.event.repository.html_url }}"    \
            --label "org.opencontainers.image.revision` `=${{ github.sha }}"                          \
            --label "org.opencontainers.image.version`  `=${IMAGE_NAME##*:}"                          \
            --label "org.opencontainers.image.created`  `=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"           \
            ./
      - name: start docker container
        run: |
          docker run -dp 80:80 --name evil-oirtail "${IMAGE_NAME}"
      - name: (nektos/act-Only) do NOT attempt surgery on liatrio apprentice-action
        if: ${{ env.ACT }}
        run: |
          printf '%s\n' '(NEKTOS/ACT-ONLY)'
      - name: (Github-Only) attempt surgery on liatrio apprentice-action
        if: ${{ !env.ACT }}
        run: |
          printf '%s\n' '(GITHUB-ONLY IN-FLIGHT-PATCH)'
          target="$(find ../../_actions/liatrio/ -type f -name 'endpoint.test.js')"
          line_1="$(grep -n ' *it("should return a minified JSON object.", async () => {'    "${target}" | cut -d: -f1 || echo 0)"
          line_2="$(grep -n ' *const res = await axios(`http://${dockerBridgeIP}:80/`);'     "${target}" | cut -d: -f1 \
          | grep "^$((line_1+1))$" || echo 0)"
          line_3="$(grep -n ' *// TODO: Finish this test'                                    "${target}" | cut -d: -f1 || echo 0)"
          line_4="$(grep -n ' *throw new Error("TypeError: Object(...) is not a function");' "${target}" | cut -d: -f1 || echo 0)"
          line_5="$(grep -n ' *});'                                                          "${target}" | cut -d: -f1 \
          | grep "^$((line_4+1))$" || echo 0)"
          if [ -n "${target}" ]             \
          && [ "$((line_5-line_4))" -eq 1 ] \
          && [ "$((line_4-line_3))" -eq 1 ] \
          && [ "$((line_3-line_2))" -eq 1 ] \
          && [ "$((line_2-line_1))" -eq 1 ]
          then
          cat > patch.txt << 'EOF'
                  const res = await axios({
                    url: `http://${dockerBridgeIP}:80/`,
                    method: "get",
                    transformResponse: [(data) => data]
                    });
                  expect(() => JSON.parse(res.data)).to.not.throw();
                  expect(/\s/.test(res.data.replace(/"(\\.|[^"\\])*"/g, "\"\""))).to.be.false;
          EOF
          sed -i'' "${line_2},${line_4}d" "${target}"  # delete the bad code
          sed -i'' "${line_1}r patch.txt" "${target}"  # inject patch
          fi
      - name: evaluate docker image
        uses: liatrio/github-actions/apprentice-action@7208146c9ce4749b4ff44ff8030d953a578fa209
      - name: stop docker container
        run: |
          docker rm -f evil-oirtail
